## static

对于变量的声明，由默认的external变为internal

### 1.全局静态变量

关键字static；

静态存储区，程序运行期间一直存在；

声明文件之外不可见

### 2. 局部静态变量

关键字static

静态存储区

作用域仅在定义函数和语句中，出了作用域不会被销毁，直至再次被调用

### 3.静态函数

只可在本文件内使用，不会与其他文件中重名的函数冲突

### 4.类静态成员

类中多个对象之间数据共享，不会破坏隐藏的原则，保证了安全性，可以被”类+成员名“访问（规范），也可以是“对象+成员名”访问（不规范），也就是无论定义了多少个对象，静态成员只有一个，其中一个静态成员被对象修改，则所有对象的静态成员被修改。

### 5.类静态函数

只能访问静态数据成员，不能访问普通数据成员，在编译时就已经确定运行时机

## C++/C区别

C++：面向对象，具有[封装](#fz)、[继承](#jc)、[多态](#dt)，有许多类型安全的功能（强制类型转换），支持范式编程

C：结构化语言





## 四种cast转换

### const_cast

将const变量转为非const

### static_cast



### dynamic_cast

### reinterpret_cast

用于任意类型的指针之间的转换，对转换的结果不做任何保证



## 指针与引用的区别

|              |     指针     |          引用          |
| :----------: | :----------: | :--------------------: |
|     空间     | 有自己的空间 |      只是一个别名      |
|     大小     |      4       |    被引用对象的大小    |
|    初始化    |  可以为NULL  |   必须是一个已有对象   |
| 作为参数传递 |  需要解引用  | 改变引用即改变所指对象 |



## 值传递、引用传递、指针传递

- 值传递:形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参->形参），参数的值只能传入，不能传出
- 引用传递:对形参的操作其实就是对实参的操作
- 指针传递：形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作

## 智能指针

主要是管理堆上分配的内存，以防申请的空间在函数结束时忘记释放，造成内存泄漏。智能指针可以看做是一个类，超出作用域之后会自动调用析构函数。都定义在memory头文件中

### auto_ptr(已经弃用)

### shared_ptr

允许多个指针指向同一个对象，每个指针都存在一个计数器，当计数器为0时，自动释放自己所管理的对象

### weak_ptr

是一种弱引用指向shared_ptr所指向的对象，当两个对象互相使用一个shared_ptr成员变量指向对方，会造成循环引用，导致内存泄漏，使用weak_ptr可以检测所管理的对象是否释放，避免非法访问

### unique_ptr

保证一个时间只有一个智能指针可以指向该对象，不支持普通的拷贝或赋值，可以通过release()来将某个智能指针置空，reset()释放原来的内存来实现某个指针所指对象的转移



## 指针与数组

| 指针                             | 数组                         |
| -------------------------------- | ---------------------------- |
| 保存数据的地址                   | 保存数据                     |
| 间接访问数据                     | 直接访问数据                 |
| 多用于动态的数据结构             | 用于固定数目且类型相同的元素 |
| 通过Malloc分配内存，free释放内存 | 隐式的分配和删除             |
| 通常操作匿名函数                 | 自身即为数据名               |

## 堆与栈

都是指内存空间，堆是按需申请，动态分配，而且需要主动free、delete；栈是程序运行时自动拥有的一小块内存，在编译时期由编译器参数决定，用于局部变量的存放或者函数调用栈的保存，栈的空间有限制，一旦局部变量申请过多（例如开个超大数组），或者函数调用太深（例如递归太多次），那么就会导致栈溢出（Stack Overflow），操作系统这时候就会直接把程序杀掉

## 内存泄漏

程序分配了一块内存，但已经不再持有引用这块内存的对象（通常是指针），虽然这些内存被分配出去，但是无法收回，将无法被其他的进程所使用，我们说这块内存泄漏了，被泄漏的内存将在整个程序声明周期内都不可使用

**原因：**

- new或者malloc动态分配堆上空间没有及时使用delete或free释放
- 局部分配的内存没有在调用者函数体内释放

## 野指针

指向一个已删除的对象或访问受限内存区域



## new/delete,malloc/free

### new/delete

new会调用构造函数，不用指定内存大小，返回的指针不用强转

### malloc/free

需要指明申请内存空间的大小，返回的指针需要强转，不需要调用构造函数和析构函数

## 宏（#define）

编译预处理功能之一，用宏来代替常量或者表达式，便于阅读理解，比函数调用具有更高的时间效率。使用带参数的宏，不占有内存，即能减少系统内存的使用，提高运行效率

## 封装

 隐藏对象的属性和细节，仅对外公开接口和对象进行交互

- c++中默认访问权限是私有的
- protected和private在单个类中的功能是一样的，区别主要体现在继承上

| 访问属性  | 属性 | 类的内部 | 类的外部 | 子类函数 | 类的对象 |
| --------- | ---- | -------- | -------- | -------- | -------- |
| public    | 公有 | 可访问   | 可访问   | 可访问   | 可访问   |
| protected | 私有 | 可访问   | 不可访问 | 可访问   | 不可访问 |
| private   | 私有 | 可访问   | 不可访问 | 不可访问 | 不可访问 |



## 继承

通过已有的数据类型来定义新的数据类型（派生类），新的数据类型不仅有新定义的成员，还拥有基类的成员，默认为私有继承，还有公有继承、保护继承（基类中所有公有成员和保护成员都是派生类的保护成员，只能被派生类的成员函数或友元访问）

### 多重继承

会导致子类中有多个来自不同父类且重复的参数，因此需要使用虚基类，虚基类构造函数优先程度最高

## 多态

“一个接口，多个方法”，使得代码模块化，

- 编译时多态性（静态多态）：通过重载函数实现：先期联编 early binding
- 运行时多态性（动态多态）：通过虚函数实现 ：滞后联编 late binding，通过虚函数来实现，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(Override)，或者称为重写



## 内联函数

将一个小的操作定义为函数的好处有：

- 方便阅读和理解
- 方便修改
- 函数可以重用

但是调用函数比等价表达式慢得多，要保存寄存器，并在返回时恢复

关键字`inline`与==函数定义体==放在一起使函数成为内联函数，目的是提高函数执行效率，消除了调用函数的额外开销

主要用于函数体较小的场合，虚函数和递归函数不会被正常内联，

## 虚函数、析构函数

### 虚函数

被virtual修饰的成员函数，作用是实现多态性，虚函数在运行时动态绑定,因为用了虚函数表机制，调用的时候会增加一次内存开销

**虚函数表**：子类若重写父类虚函数，虚函数表中，该函数的地址会被替换

通常是将会被继承的基类函数的析构函数设置为虚函数，保证基类指针可以指向子类对象后，释放基类指针时，释放掉子类的空间，防止内存泄露

### 构造函数

不能是虚函数，本身是为了明确初始化对象成员，虚函数主要是为了在不完全了解细节的情况下也能正确处理对象

### 析构函数

当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数

默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。只有当需要当作父类时，设置为虚函数

## 常量定义、存储

加上const，常量必须初始化；

局部对象：存放在栈区

全局对象：静态存储区

字面值常量：常量存储区

## 重载与覆盖：

重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中

重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写



## STL

### 构成

- 容器
- 迭代器
- 仿函数：协助算法完成各种操作
- 算法：通过迭代器获取容器中的内容
- 分配器：给容器分配存储空间
- 配接器：套接适配仿函数

### 删除元素

- 序列容器vector、deque：使用erase(itertor)后，后边的每个元素的迭代器都会失效，后边每个元素都会往前移动一个位置，并会返回下一个有效的迭代器
- 关联容器map、set：使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影响到下一个元素的迭代器，在调用erase之前，记录下一个元素的迭代器即可

### map：

所有元素都是 pair，会根据元素的键值自动被排序，不允许重复，支允许修改value，持下表操作，

底层红黑树实现

### Multimap：

multimap 的所有元素都是 pair，会根据元素的键值自动被排序，允许重复

底层实现红黑树

### set：

迭代器是const的，不允许修改元素的值，不支持下标操作，



### vector

连续存储的容器，动态数组，在堆上分配空间

底层实现：数组

两倍容量增长

如果没有剩余空间了，则会重新配置原有元素个数的两倍空间，然后将原空间元素通过复制的方式初始化新空间，再向新空间增加元素，最后析构并释放原空间，之前的迭代器会失效

适用场景：经常随机访问，且不经常对非尾节点进行插入删除

### List

动态链表，在堆上分配空间，每插入一个元数都会分配空间，每删除一个元素都会释放空间。

底层：双向链表

适用场景：经常插入删除大量数据














