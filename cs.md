[toc]

## 进程线程

### 概念

- 进程：对运行时==程序的封装==，是==系统进行资源调度和分配==的基本单位，实现了==操作系统的并发==
- 线程：进程的子任务，是==CPU调度和分派==的基本单位，实现进程内部并发，是操作系统可识别的最小执行和调度单位，每个线程独占一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同任务，共享一个地址空间

### 区别

- 一个线程只属于一个进程，进程可以有多个线程，至少一个，线程依赖于进程而存在

- 进程是资源分配的最小单位，线程是CPU调度的最小单位
- 进程拥有独立的内存单元，线程共享进程内存
- 撤销进程时，会收回资源例如内存空间、IO设备等，进程切换时，涉及整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境设置，而线程切换只需要保存少许寄存器的内容，系统付出的开销明显要小很多。线程间会互相影响，可靠性弱，进程间拥有独立运行的地址空间，可靠性强
- 通信：
  - 进程间通信包括管道、IPC（消息队列、信号量、信号、共享内存）、套接字socket
    - 管道：无名管道、命名管道。管道可以使具有亲缘关系之间的进程间通信，命名管道还可以使无亲缘关系的进程间通信
    - 系统IPC：==消息队列==是消息的链表，进程可以修改和读取，但不会因进程终止而被删除，是独立的，可以随机查询；==信号量==是一个计数器，用来控制进程对共享资源的访问。实现进程间的互斥与同步；==信号==用于通知接收进程某个事件已经发生；==共享内存==使多个进程访问同一块内存空间，可以让不同进程及时看到共享内存中数据的更新，需要依靠同步操作，如互斥锁、信号量等
    - 套接字：可用于不同主机间进程通信
  - 线程具有相同的地址空间，可以实现同步，临界区、互斥量、信号量、事件
    - 临界区：多线程串行话访问公共资源或者一段代码，速度快
    - 互斥量：互斥锁，只有拥有互斥对象的线程才有访问公共资源的权限，进入临界区时获得互斥锁，离开时唤醒等待互斥锁的线程
    - 信号量：控制具有有限数量的用户资源，允许多个线程同时去访问同一资源，但会限制最大线程数目，只取自然数，支持两种操作：1）P操作如果信号量大于0，则减1，为0，则挂起；2）V操作如果有信号量因等待而挂起，则加1，否则直接加1
    - 事件：通过通知操作保持多线程同步、实现多线程优先级比较

### 多线程优缺点

**优点：**场景：1）处理器耗时长而占用用户界面操作的任；2）各个任务需等待外部资源

- 程序响应更快
- 可以将cpu让给需要的任务
- 可以设置各个任务优先级别，优化性能
- 耗时长的任务可以定期给时间执行

**缺点：**

- 等候公共资源（独占性资源）耗时
- 线程管理需要额外cpu开销
- 线程死锁
- 共有变量的同时读写

### 线程需要保存的上下文

当前ID、线程状态、堆栈、寄存器状态等信息，其中寄存器主要包括SP PC EAX等寄存器

- SP：堆栈指针
- PC：程序计数器，存储下一条将要执行的指令
- EAX：累加寄存器，用于加法乘法的缺省寄存器



### 死锁发生的条件及解决

指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象

- 互斥条件
- 请求和保持条件：进程获得一定资源后，对其它已被占有的资源进行申请，发生请求阻塞，而不会释放已占有的资源
- 不可剥夺条件：已获得的资源在未完成使用前不会被释放
- 环路等待条件：发生死锁后必存在进程-资源之间的环形链

解决死锁的方法：

- 资源一次性分配
- 可剥夺资源
- 资源有序分配法



## Linux 物理内存

Linux内核采用页式存储管理，进程的地址空间分配为固定大小的“页面”，物理内存分配为页面大小相同的“页帧",由MMU在运行时将虚拟地址“映射”成某个物理内存页面上的地址。

## Linux虚拟地址空间

为防止不同进程同一时刻在物理内存中运行而对物理内存的争夺。进程在创建和加载时，内核只创建了虚拟内存的布局，并不是直接拷贝到物理内存中，只需要建立好虚拟内存与磁盘文件之间的映射。

优点：

- 扩大地址空间
- 内存保护，互不干扰，防止数据被恶意篡改
- 公平内存分配
- 进程通信时可以采用虚存共享的方式
- 当程序需要分配连续内存空间时，只需要虚拟内存连续即可

代价：

- 虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存
- 虚拟地址到物理地址的转换，增加了指令的执行时间
- 页面的换入换出需要磁盘I/O，很耗时
- 如果一页中只有一部分数据，会浪费内存

### 虚拟内存置换方式

访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换

- FIFO：最近刚访问的将来访问的可能性大，使用队列来实现，置换在内存中驻留时间最久的页面，无法体现页面冷热信息
- LFU：如果数据过去被访问多次，那么将来被访问的频率也会更高，会对每个数据块有一个引用计数，并按照计数进行排序，每次淘汰队尾，排序的开销很大
- LRU：最近刚访问的将来访问的可能性大，使用堆栈来实现，置换最长时间未访问的页面

## 操作系统程序的内存结构

本质上都是由BSS段、data段、text段三个组成的。

- BSS段（未初始化数据区）：存放程序中未初始化的全局变量和静态变量的一块内存区域，属于静态分配，结束后由系统自动释放

- 数据段：存放程序中已初始化的全局变量的一块内存区域。数据段也属于静态内存分配

- 代码段：这部分区域的大小在程序运行前就已经确定，并且内存区域属于只读

程序在执行时产生两个区域：栈区、堆区

- 栈区：编译器自动释放，存放参数值、局部变量、调用信息等
- 堆区：用于动态分配内存，由程序员申请分配和释放,采用链式存储结构，容易产生碎片，效率比栈低

## 内存对齐

性能以及平台移植，编译器对数据结构进行内存对齐

- **前面的地址必须是后面的地址正数倍,不是就补齐**
-  **整个Struct的地址必须是最大字节的整数倍**
-  **如程序中有#pragma pack(n)预编译指令，则所有成员对齐以n字节为准(即偏移量是n的整数倍)，不再考虑当前类型以及最大结构体内类型**

```c++
struct A{
    char a;
    int b;
    short c;
};

struct B{
    short c;
    char a;
    int b;
};
int main(){
    cout<<sizeof(A)<<endl;		//12
    cout<<sizeof(B)<<endl;		//8
    return 0;
}
```





## 操作系统缺页中断

内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常。

缺页中断：当所要访问的页面不在内存时，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存

步骤：

- 保护CPU现场
- 分析中断原因
- 转入缺页中断处理程序进行处理
- 恢复CPU继续运行

缺页中断是由硬件所产生的一种特殊的中断，与一般的中断存在区别：

- 在指令执行期间产生和处理缺页中断信号
- 一条指令在执行期间，可能产生多次缺页中断
- 缺页中断是执行一条指令，一般中断是执行下一条指令

## 操作系统中页表寻址

操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表，页表的内容就是该进程的虚拟地址到物理地址的一个映射，页式内存管理的优点就是比较灵活，内存管理以较小的页为单位，方便内存换入换出和扩充地址空间

### linux 两级页表机制

两级分页机制将32位的虚拟空间分成三段，低十二位表示==页内偏移==，高20分成两段分别表示两级页表的偏移

- PGD：高10位，全局页表目录表索引
- PTE：中间10位，页表入口索引

### linux三级页表机制

当引入物理地址扩展后，可以支持大于4G的物理内存，但虚拟地址仍然是32位，页表层级发生了变化，新增一个页中间目录（PMD），是虚拟化的，外部看起来还是两级页表

### linux 四级页表机制



## fork、vfork区别

## 修改文件最大句柄数

> 能够打开的最大文件的数量

`ulimit -a`:查询系统句柄，open file 为最大文件句柄数

`ulimit -n num`:修改最大句柄数为n，只对当前shell有用

修改limits.conf文件，永久有效



## 并发、并行

并发在宏观上看是两个程序同时运行，但是从微观上只是两个程序的指令在交替运行，并不能提高计算机性能，只是提高了效率

并行是同时，运行两个程序互不影响，提高了计算机的效率


## Linux 四种锁
### 互斥锁、读写锁

**互斥锁：**保证任何时刻都只有一个线程访问该对象，当获取锁操作失败时，线程会进入睡眠，等待锁释放被唤醒

**读写锁：**分为读锁和写锁，当为读操作时，可以允许多个线程同时操作，但是同一时刻只能允许一个线程可以获得写操作，其余进入休眠，直至写锁释放被唤醒。写锁会阻塞其他读写锁，当有一个线程获得写锁，读锁不能被其他线程获取。适用于读操作远大于写操作

**区别：**读写锁有读锁和写锁，互斥锁没有，即一个时间只能有一个线程访问资源

### 自旋锁

任何时间只有一个线程可以访问对象，在获取锁操作失败时，不会进入睡眠，而是原地自旋，这样就节省了线程从睡眠状态到被唤醒间的消耗，缺点是如果某个线程持有锁的时间过长，会由于循环等待而导致消耗CPU

### RCU

修改数据时先读取数据，再生成一个副本，对副本进行修改，最后update成新的数据。对于读者而言几乎不需要同步开销，不用考虑死锁的问题，写者的同步开销很大。





