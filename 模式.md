# 单例模式

私有化构造函数，使用类的私有静态指针变量指向类的唯一实例，用公有静态方法获取实例

**实现方法：**

- 懒汉模式：用的时候再初始化

```c++
class Singleton
{
private:
    static Singleton* p;
    Singleton(){};

public:
    static Singleton* getInstance()
    {
        if (p == nullptr)
            p = new Singleton();
      	return p;
    }
}
```

以上代码存在一个问题就是当两个线程都在调用这个对象时，都会判空，会分别实例化这个对象，，出现线程安全的问题。

- 饿汉模式：程序运行时立即初始化,调用时直接返回单例对象，并在调用时加上锁，保证线程安全

```c++
using namespace std;
std::mutex mt;

class Singleton{
	private:
  	static Singleton* p;
  	Singleton(){}
  	~Singleton(){}
  public:
  	static Singleton* getinstance(){
      if(p==nullptr){
        mt.lock();
        if(p==nullptr)
          p = new Singleton();
        mt.unlock;
      }
      return p;
    }
};
Singleton* Singleton::P = 0;
```

**双检锁：**避免了每次来获取实例都需要加锁的情况，并发性能差的缺点，倘若实例已经存在，直接返回实例即可

**指令重排序：**编译器在不改变执行效果的前提下，对指令顺序进行调整，从而提高执行效率的过程。此处单例实现分为三个步骤：

- singleton对象分配空间

- 在分配空间构造对象

- 使指针指向分配的空间

	然而此处可能会发生2、3步骤交换的情况，例如A线程先执行了1、3步骤然后挂起，则此时p不为NULL，但是所指区域没有对象，B线程调用此单例，发现不为空，直接返回



**优点：**

- 只有一个实例，减少内存开销
- 当对象所需较多资源，较少系统性能开销
- 避免对资源多重占用

**缺点：**

- 扩展困难



# 工厂模式

封装和管理对象的创建，不会向客户端暴露创建逻辑，通过一个共同的接口指向新创建的对象，使一个类的实例化延迟，利用虚函数，达到解耦的目的

## 简单工程模式

又称作静态工厂方法，仅仅简单的对不同类对象的创建进行了一层薄薄的封装

## 工厂方法模式

将具体的方法分发给具体的产品工厂，实现了扩展而非修改，缺点在于要求创建方法，参数相同

## 抽象工厂模式

一系列相互依赖的对象的创建工作，提供一个借口负责创建所有相关联的对象，便于应对新系列，但是对于新对象，就不适用

# 观察者

# 职责链

